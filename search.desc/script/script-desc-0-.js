searchState.loadedDescShard("script", 0, "Script engine\nappend a <code>.fail()</code> after <code>ret_parse_error</code>, so compiler can …\nScripts manager\nPython script coprocessor\nScripts table\nCompile script context\nEvaluate script context\nCompile a script text into a script instance.\nReturns the script engine name such as <code>python</code> etc.\nExecute the script and returns the output.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the script engine name such as <code>python</code> etc.\nSNAFU context selector for the <code>Error::BuildDfLogicalPlan</code> …\nSNAFU context selector for the <code>Error::CastType</code> variant\nSNAFU context selector for the <code>Error::CollectRecords</code> …\nSNAFU context selector for the <code>Error::CompilePython</code> variant\nContains the error value\nSNAFU context selector for the …\nSNAFU context selector for the <code>Error::ExecutePython</code> variant\nSNAFU context selector for the …\nSNAFU context selector for the <code>Error::InsertScript</code> variant\nContains the success value\nSNAFU context selector for the <code>Error::ScriptNotFound</code> …\nSNAFU context selector for the <code>Error::ScriptsTableNotFound</code> …\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>ToString::to_string</code>, but without panic on OOM.\ncompile script, and register them to the query engine and …\ncompile script to PyScript, but not register them to the …\nReturns the argument unchanged.\nGet the scripts table in the catalog\nInsert a scripts table.\nCalls <code>U::from(self)</code>.\nPython script engine\nFake a schema, should only be used with dynamically eval a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRegister to <code>FUNCTION_REGISTRY</code>\nRegister Current Script as UDF, register name is same as …\n<code>ToString::to_string</code>, but without panic on OOM.\nSNAFU context selector for the <code>Error::Arrow</code> variant\nerrors in coprocessors’ parse check for types and etc.\nSNAFU context selector for the <code>Error::CoprParse</code> variant\nSNAFU context selector for the <code>Error::DataFusion</code> variant\nSNAFU context selector for the <code>Error::DatabaseQuery</code> variant\nContains the error value\nSNAFU context selector for the <code>Error::NewRecordBatch</code> …\nContains the success value\nOther types of error that isn’t any of above\nSNAFU context selector for the <code>Error::Other</code> variant\nSNAFU context selector for the <code>Error::PyCompile</code> variant\nSNAFU context selector for the <code>Error::PyParse</code> variant\nrustpython problem, using python virtual machines’ …\nSNAFU context selector for the <code>Error::PyRuntime</code> variant\nSNAFU context selector for the <code>Error::RecordBatch</code> variant\nSNAFU context selector for the <code>Error::TokioJoin</code> variant\nSNAFU context selector for the <code>Error::TypeCast</code> variant\nSNAFU context selector for the <code>Error::UnsupportedSql</code> …\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nEnsure a condition is true. If it is not, return from the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nextract a reason for <code>Error</code> in string format, also return a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\npretty print <code>Error</code> in given script, basically print a …\n<code>ToString::to_string</code>, but without panic on OOM.\npretty print a location in script with desc.\nPyRecordBatch is a Python class that wraps a RecordBatch, …\nget from python function args’ annotation, first is …\nUse which backend to run this script Ideally in test both …\ncheck if real types and annotation types(if have) is the …\nmatch between arguments’ real type and annotation types …\ncompile script to code object\nif None, use types inferred by PyVector\nusing a parsed <code>Coprocessor</code> struct as input to execute …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\ngenerate <code>Schema</code> according to return names, types, if no …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nkwargs in coprocessor function’s signature\nget from python function returns’ annotation, first is …\nstore its corresponding script, also skip serde when in …\nselect columns according to <code>fetch_names</code> from <code>rb</code> and cast …\nreturn sql query results in <code>PyRecordBatch</code>,  ora empty …\nstripe the decorator(<code>@xxxx</code>) and type annotation(for type …\ngenerate a call to the coprocessor function with arguments …\ncheck for the grammar correctness of annotation, also …\ncheck if binary op expr is legal(with one typename and one …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nparse script and return <code>Coprocessor</code> struct with info …\nwhere:\nparse a <code>DataType | None</code> or a single <code>DataType</code>\nreturns args and returns in Vec of String\nparse a list of keyword and return args and returns list …\nItem =&gt; NativeType default to be not nullable\nturn a python list of string in ast form(a <code>ast::Expr</code>) of …\nReturn a CoprParseSnafu for you to chain fail() to return …\nThis is a Wrapper around a RecordBatch, impl PyMapping …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBecause most of the datafusion’s UDF only support …\nGenerate friendly error message when the type of the input …\nThe Main FFI type <code>PyVector</code> that is used both in RustPython …\nPerforms <code>val / arr</code>, but cast to i64.\nPerforms <code>val - arr</code>.\nPerforms <code>val / arr</code>\ncreate a ref to inner vector\nReturns the type that should be used for the result of an …\ntake a boolean array and filters the Array, returning …\nReturns the argument unchanged.\nget corresponding arrow op function according to given …\nget corresponding arrow scalar op function according to …\nReturn a <code>PyVector</code> in <code>PyObjectRef</code>\nCalls <code>U::from(self)</code>.\nrich compare, return a boolean array, accept type are vec …\nif this pyobj can be cast to a scalar value(i.e …\nUnsupported TODO(discord9): make it work\nconvert a DataType <code>Value</code> into a <code>PyObjectRef</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBuiltin module contains GreptimeDB builtin udf/udaf\nPyVectors’ rustpython specify methods\nBecause most of the datafusion’s UDF only support …\nThe macro for binding function in …\nuse to bind to Data Fusion’s UDF function P.S: seems due …\nevaluate Aggregate Expr using its backing accumulator\nGrepTime User Define Function module\nturn a ScalarValue into a Python Object, currently support\ntry to turn a Python Object into a PyVector or a scalar …\ncast a columnar value into python object\n“Can’t cast operand of type <code>{name}</code> into <code>{ty}</code>.”\nsimple math function, the backing implement is datafusion…\nsimple math function, the backing implement is datafusion…\nNot implement in datafusion TODO(discord9): use greptime’…\neffectively equals to <code>list(vector)</code>\nsimple math function, the backing implement is datafusion…\nsimple math function, the backing implement is datafusion…\ndirectly port from datafusion’s <code>avg</code> function\nsimple math function, the backing implement is datafusion…\ncollect <code>DataFrame</code> results into <code>PyRecordBatch</code> that impl …\nsimple math function, the backing implement is datafusion…\nget <code>__dataframe__</code> from globals and return it …\nsimple math function, the backing implement is datafusion…\nreturn first element in a <code>PyVector</code> in sliced new <code>PyVector</code>, …\nsimple math function, the backing implement is datafusion…\nReturns the argument unchanged.\nTODO(discord9): error handling\ngenerate interval time point\n<code>func</code>: exec on sliding window slice of given <code>arr</code>, expect it …\nCalls <code>U::from(self)</code>.\nreturn last element in a <code>PyVector</code> in sliced new <code>PyVector</code>, …\nsimple math function, the backing implement is datafusion…\nsimple math function, the backing implement is datafusion…\nsimple math function, the backing implement is datafusion…\nPow function, bind from gp’s <code>PowFunction</code>\nGrepTime’s own impl of pow function\nget <code>__query__</code> from globals and return it TODO(discord9): …\nreturn a random vector range from 0 to 1 and length of len\nsimple math function, the backing implement is datafusion…\nsimple math function, the backing implement is datafusion…\nsimple math function, the backing implement is datafusion…\nsimple math function, the backing implement is datafusion…\nsimple math function, the backing implement is datafusion…\ninit interpreter with type PyVector and Module: greptime\nUsing <code>RustPython</code> to run a parsed <code>Coprocessor</code> struct as …\nset arguments with given name and values in python scopes\nconvert a tuple of <code>PyVector</code> or one <code>PyVector</code>(wrapped in a …\nwith <code>register_batch</code>, and then wrap DataFrame API in it\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>~</code> operator, return <code>!self</code>\nset DataFrame instance into current scope with given name\nsort ascending&amp;nulls_first\nuse <code>rustpython</code>’s <code>is_instance</code> method to check if a …\nconvert a single PyVector or a number(a constant)(wrapping …\nconvert a <code>PyObjectRef</code> into a <code>datatypes::Value</code>(is that ok?) …\nPlease only use this method because you are calling from …\njust like <code>tokio::task::spawn_blocking</code> but using a …\nThe scripts table that keeps the script content etc.\nBuild the inserted column schemas\nBuilds scripts schema, returns (time index, primary keys, …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new <code>[ScriptsTable]</code> based on the table.\nthis is used as a callback function when scripts table is …")